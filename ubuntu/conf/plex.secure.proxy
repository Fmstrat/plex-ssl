# Reverse HTTPS proxy for Plex Media Server

# uncomment the below server config to allow pre-authenticatied access to this PMS server via [proxy local ip]:32400
# using the server owner's credentials
# If you have multiple PMS servers, only one can be accessed using this automated authentication proxy
#server {
#    set $pms '192.168.0.10';
#    listen 32400;
#    location @openproxy {
#        proxy_pass http://$pms:32400;
#        proxy_set_header X-Real-IP       $remote_addr;
#        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#        proxy_redirect http://$pms:32400 http://$host:$server_port;
#    }
#    location @openwebsocketproxy {
#        proxy_pass http://$pms:32400;
#        proxy_pass_request_headers on;
#        proxy_cache off;
#        proxy_buffering off;
#        proxy_http_version 1.1;
#        proxy_set_header Upgrade $http_upgrade;
#        proxy_set_header Connection $connection_upgrade;
#        proxy_set_header X-Real-IP       $remote_addr;
#        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#    }
#    location / {
#        content_by_lua '
#            local pk = ngx.shared.pmskeys
#            local token = pk:get(ngx.var.pms)
#            if token ~= nil then
#                ngx.req.set_header("X-Plex-Token", token)
#                if ngx.var.request_uri:find("^/:/websockets/") then
#                    ngx.exec("@openwebsocketproxy")
#                else
#                    ngx.exec("@openproxy")
#                end
#            else
#                ngx.exit(ngx.HTTP_UNAUTHORIZED)
#            end
#        ';
#    }
#}

server {  
  
    set $pms '192.168.0.10';

    listen 30443;

    gzip          on;
    gzip_proxied  any;
    gzip_types    text/css text/plain text/xml application/xml application/javascript application/x-javascript text/javascript application/json text/x-json;
    gzip_vary     on;
  
    ssl on;  
    ssl_certificate /opt/ssl-plex/certs/proxy.pem;  
    ssl_certificate_key /opt/ssl-plex/certs/proxy.key;  
    ssl_session_cache shared:SSL:10m;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;

    # if port was accessed as http, redirect to http connection mamanger 
    error_page 497 = @insecure;

    location @insecure {

        set $pms '192.168.0.10';

	content_by_lua '
            local args = ngx.req.get_uri_args()
            local headers = ngx.req.get_headers()
            if ngx.req.get_method() == "GET" and args["X-Plex-Token"] == nil and headers["X-Plex-Token"] == nil then
                -- If a GET and no token has been sent, redirect to https
                if ngx.re.find(ngx.var.request_uri,"^/photo/:/transcode") ~= nil then
                    ngx.exec("@proxy")
                else
                    ngx.redirect("https://" .. ngx.var.host .. ":" .. ngx.var.server_port .. ngx.var.request_uri)
                end
            else
                -- Else, log the insecure request and proxy the request
                local file = io.open("/var/log/nginx/security.log", "a+")
                local client = args["X-Plex-Client-Platform"]
                local device = args["X-Plex-Device-Name"]
                if client == nil then
                    -- try the headers
                    client = headers["X-Plex-Client-Platform"]
                    device = headers["X-Plex-Device-Name"]
                end
                if client == nil then
                    client = "unknown"
                end
                if device == nil then
                    device = "unknown"
                end
                file:write(ngx.localtime() .. 
                  "\tTOKEN EXPOSED" .. 
                  "\t" .. ngx.var.remote_addr .. 
                  "\t" .. ngx.unescape_uri(client) .. 
                  "\t" .. ngx.unescape_uri(device) .. 
                  "\t" .. ngx.req.get_method() .. 
                  "\t" .. "http://" .. ngx.var.host .. ":" .. ngx.var.server_port .. ngx.var.request_uri .. "\\n")
                file:close()
                ngx.exec("@proxy")
            end
        ';
        break;
    }

    location @proxy {

        access_by_lua '
            local uri = ngx.var.request_uri
            if ngx.re.find(uri,"^/(web|manage|video/:/transcode/universal/session)(/|$)") == nil then
                local na = true
                local args = ngx.req.get_uri_args()
                local headers = ngx.req.get_headers()
                local clt = args["X-Plex-Token"]
                if clt == nil then
                    clt = headers["X-Plex-Token"]
                end
                local pbt = args["X-Plex-Public-Token"]
                if pbt == nil then
                    pbt = headers["X-Plex-Public-Token"]
                end
                if pbt and clt == nil then
                    clt = pbt
                end
                local pk = ngx.shared.pmskeys
                local token = pk:get(ngx.var.pms)
                if clt and token then
                    local pck = ngx.shared.pmsclientkeys
                    local ek = "expires:" .. token
                    local t = ngx.time()
                    local lt = pck:get(ek)
                    local lasthash = pck:get(token .. "_" .. clt)
                    if ((((lt ~= nil and tonumber(lt) > t) or ngx.re.find(uri,"^/:/websockets") ~= nil) and (lasthash ~= nil)) or pbt ~= nil) then
                        na = false
                    else
                        local res = ngx.location.capture("/devices.xml?X-Plex-Token=" .. token)
                        if res ~= nil and res.status == ngx.HTTP_OK and res.body then
                            pck:set(ek, t + (60*10))
                            local xmlhash = ngx.md5(res.body)
                            local lasthash = pck:get("lasthash:" .. token)
                            if lasthash == nil or lasthash ~= xmlhash then
                                pck:set("lasthash:" .. token,xmlhash)
                                for ct in string.gmatch(res.body, "token=\\"([^\\"]+)\\"") do
                                    pck:set(token .. "_" .. ct, xmlhash)
                                end
                                local f = io.open("/tmp/pms_clients","w+")
                                local pke = pck:get_keys()
                                for k,v in pairs(pke) do
                                    if string.find(v, "^" .. token .. "_") ~= nil then
                                        if pck:get(v) ~= xmlhash then
                                            pck:delete(v)
                                        else
                                            f:write(v .. "\\t" .. xmlhash .. "\\n")
                                        end
                                    else
                                        f:write(v .. "\\t" .. pck:get(v) .. "\\n")
                                    end
                                end
                                f:close()
                            end
                        else
                            pck:set(ek, t + 60)
                        end
                        lasthash = pck:get(token .. "_" .. clt)
                        if lasthash then
                            na = false
                        end
                    end
                end
                if na then
                    local hd = ngx.req.get_headers()
                    local a = "Access-Control-"
                    local acr = hd[a .. "Request-Headers"]
                    if acr and ngx.re.find(acr,"x-plex-version") ~= nil then
                        ngx.header[a .. "Allow-Headers"] = acr
                        ngx.header[a.. "Allow-Methods"] = "POST, GET, OPTIONS, DELETE, PUT, HEAD"
                        ngx.header[a .. "Allow-Origin"] = "*"
                        ngx.header["X-DEBUG"] = "error"
                        ngx.header[a .. "Max-Age"] = "1209600"
                        ngx.exit(200)
                    else
                        ngx.exit(ngx.HTTP_UNAUTHORIZED)                        
                    end
                end
            end
        ';

        content_by_lua '
            local args = ngx.req.get_uri_args()
            local headers = ngx.req.get_headers()
            local st = args["X-Plex-Send-Public-Token"]
            if st == nil then
                st = headers["X-Plex-Send-Public-Token"]
            end
            local pbt = args["X-Plex-Public-Token"]
            if pbt == nil or clt == "" then
                pbt = headers["X-Plex-Public-Token"]
            end
            if pbt ~= nil then
                pbt = pbt:gsub("([^a-zA-Z0-9])","")
            end
            if ngx.re.find(ngx.var.request_uri,"^/photo/:/transcode") ~= nil then
                if pbt ~= nil then
                    local na = true
                    local f = io.open("/tmp/" .. pbt .. ".pmsxml","r")
                    if f ~= nil then
                        local clt = f:read()
                        local pk = ngx.shared.pmskeys;
                        local pck = ngx.shared.pmsclientkeys;
                        local token = pk:get(ngx.var.pms)
                        local url = args["url"]
                        if clt ~= nil and token ~= nil and url ~= nil then
                            local lasthash = pck:get(token .. "_" .. clt)
                            if lasthash ~= nil then
                                eurl = ngx.re.gsub(url,"^http://127\\.0\\.0\\.1:32400","")
                                eurl = eurl:gsub("([\\\.\\\?\\\\\\\[\\\]\\\(\\\)\\\+\\\*\\\{\\\}\\\^\\\$\\\/])","\\\\%1")
                                local xml = f:read("*a")
                                if ngx.re.find(xml," (thumb|grandparentThumb)=\\"" .. eurl .. "\\"") ~= nil then
                                    ngx.req.set_header("X-Plex-Token", clt)
                                    na = false
                                end
                            end
                        end
                        f:close()
                    end
                    if na then
                        ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    else
                        ngx.exec("@standardproxy")
                    end
                else
                    ngx.exec("@standardproxy")
                end
            elseif pbt ~= nil then
                ngx.exit(ngx.HTTP_UNAUTHORIZED)
            elseif ngx.re.find(ngx.var.request_uri,"^/:/websockets") ~= nil then
                ngx.exec("@websocketproxy")
            elseif st ~= nil and st == "true" then
                ngx.exec("@send_public_token")
            elseif ngx.re.find(ngx.var.request_uri,"^/servers") ~= nil then
                local i3,i2,i1,i0 = ngx.var.remote_addr:match("([0-9]+)\\.([0-9]+)\\.([0-9]+)\\.([0-9]+)")
                local intip = (i3 * math.pow(256,3)) + (i2 * math.pow(256,2)) + (i1 * 256) + i0
                local psn = ngx.shared.pmssubnets
                local pse = psn:get_keys()
                local islocal = false
                local device = args["X-Plex-Device-Name"]
                if device == nil then
                    device = headers["X-Plex-Device-Name"]
                end
                if device == nil then
                    device = "unknown"
                end
                local isweb = device:find("^Plex Web") ~= nil
                for k,v in pairs(pse) do
                    if math.floor(intip/psn:get(v)) == tonumber(v) then
                       islocal = true
                    end
                end
                if islocal and isweb == false then
                    ngx.exec("@standardproxy")
                else
                    ngx.exec("@non_local_servers")
                end
            else
                ngx.exec("@standardproxy")
            end
        ';

    }

    location @standardproxy {

        proxy_pass http://$pms:32400;
        proxy_pass_request_headers on;

        proxy_set_header X-Real-IP       $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_redirect http://$pms:32400 https://$host:$server_port;

    }

    location @websocketproxy {

        proxy_pass http://$pms:32400;
        proxy_pass_request_headers on;
        proxy_cache off;
        proxy_buffering off;

        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        proxy_set_header X-Real-IP       $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    }

    location @non_local_servers {

        set $pmsnonlocalcomplete 'false';

        proxy_pass http://$pms:32400;
        proxy_pass_request_headers on;
        proxy_set_header Host $host:$server_port;
        proxy_set_header Accept-Encoding "";
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        header_filter_by_lua '
            ngx.header.content_length = nil
            ngx.var.pmsnonlocalcomplete = "false";
        ';

        body_filter_by_lua '
            local ph = ngx.shared.pmshosts
            local hp = ph:get(ngx.var.pms)
            local h,p = hp:match("([^:]+):([^:]+)")
            if h ~= nil then
                local pmsip = ngx.re.gsub(ngx.var.pms,"\\\.","\\\\.")
                local m,err = ngx.re.match(ngx.arg[1],"(\\<Server.+?host=\\"" .. pmsip .. "\\".*?/\\>)")
                local pmse = ""
                local size = 0
                if m and m[0] ~= nil then
                    pmse = m[0]
                    size = 1
                end
                if (size > 0 or ngx.arg[2]) and  ngx.var.pmsnonlocalcomplete == "false" then
                    ngx.var.pmsnonlocalcomplete = "true"
                    local xml = "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?><MediaContainer size=\\"" .. size .. "\\">" .. pmse .. "</MediaContainer>"
                    xml = ngx.re.gsub(xml,"address=\\"" .. pmsip .. "\\"", "address=\\"" .. h .. "\\" scheme=\\"https\\"")
                    xml = ngx.re.gsub(xml,"host=\\"" .. pmsip .. "\\"", "host=\\"" .. h .. "\\"")
                    xml = ngx.re.gsub(xml,"port=\\"[^\\"]+\\"", "port=\\"" .. p .. "\\"")
                    ngx.arg[1] = xml
                else
                    ngx.arg[1] = ""
                end
            end
        ';
    }

    location @send_public_token {

        proxy_pass http://$pms:32400;
        proxy_set_header Host $host:$server_port;
        proxy_set_header Accept-Encoding "";
        proxy_set_header X-Real-IP       $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        header_filter_by_lua '
            ngx.header.content_length = nil
            local args = ngx.req.get_uri_args()
            local headers = ngx.req.get_headers()
            local clt = args["X-Plex-Token"]
            if clt == nil then
                clt = headers["X-Plex-Token"]
            end
            if clt ~= nil then
                local pbt = ngx.md5(clt .. ":" .. ngx.var.request_uri)
                local f = io.open("/tmp/" .. pbt .. ".pmsxml","w+")
                if f ~= nil then
                    f:write(clt .. "\\n")
                    f:close()
                end
            end
        ';

        body_filter_by_lua '
            local args = ngx.req.get_uri_args()
            local headers = ngx.req.get_headers()
            local clt = args["X-Plex-Token"]
            if clt == nil then
                clt = headers["X-Plex-Token"]
            end
            if clt ~= nil then
                local pbt = ngx.md5(clt .. ":" .. ngx.var.request_uri)
                local f = io.open("/tmp/" .. pbt .. ".pmsxml","a+")
                if f ~= nil then
                    f:write(ngx.arg[1])
                    f:close()
                end
                ngx.arg[1] = ngx.re.gsub(ngx.arg[1],"(<MediaContainer)", "$1 publicToken=\\"" .. pbt .. "\\"")
            end
        ';

    }

    location /devices.xml {
        # get tokens for allowed clients from plex.tv
        internal;
        proxy_pass https://www.plex.tv;
        proxy_pass_request_headers off;
        proxy_set_header Host plex.tv;
    }

    # modify plex.js response to fix some issues with websockets
    # something similar seems to be in v2.2.7 now 
    #location = /web/js/plex.js {
    #    proxy_pass http://$pms:32400;
    #    proxy_set_header Host $host:$server_port;
    #    proxy_set_header Accept-Encoding "";
    #    proxy_set_header X-Real-IP       $remote_addr;
    #    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    #    header_filter_by_lua ' 
    #        ngx.header.content_length = nil 
    #    '; 
    #    body_filter_by_lua ' 
    #        ngx.arg[1] = ngx.re.sub(ngx.arg[1],"\\"ws://\\"", "((location.protocol === \\"https:\\")?\\"wss://\\":\\"ws://\\")") 
    #    '; 
    #}

    location / {
        content_by_lua '
            ngx.exec("@proxy")
        ';
    } 
}
